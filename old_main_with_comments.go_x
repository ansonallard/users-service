package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"runtime"

	"github.com/ansonallard/users-service/internal/api"
	"github.com/ansonallard/users-service/internal/controller"
	"github.com/ansonallard/users-service/internal/env"
	"github.com/ansonallard/users-service/internal/service"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3filter"
	"github.com/getkin/kin-openapi/routers"
	"github.com/getkin/kin-openapi/routers/gorillamux"
	"github.com/gin-gonic/gin"
)

const (
	OPENAPI_SPEC_FILE_PATH = "public/tenants.openapi.yaml"
)

const (
	OAUTH_TOKEN_ROUTE     = "/oauth/token"
	OAUTH_AUTHORIZE_ROUTE = "/oauth/authorize"
	USERS_LOGIN           = "/users/login"
)

//go:generate go run github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen -config=types.cfg.yaml public/tenants.openapi.yaml

type responseWriter struct {
	gin.ResponseWriter
	body []byte
}

func (w *responseWriter) Write(b []byte) (int, error) {
	w.body = append(w.body, b...)
	return w.ResponseWriter.Write(b)
}

func ValidationMiddleware(router routers.Router) gin.HandlerFunc {
	return func(c *gin.Context) {
		// c.Header("Access-Control-Allow-Origin", "http://localhost:3000")

		// return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Find route
		route, pathParams, err := router.FindRoute(c.Request)
		if err != nil {
			// http.Error(w, fmt.Sprintf("Error finding route: %v", err), http.StatusBadRequest)
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Error finding route: %v", err)})
			c.Abort()
			return
		}

		// Create validation context
		ctx := context.Background()
		requestValidationInput := &openapi3filter.RequestValidationInput{
			Request:    c.Request,
			PathParams: pathParams,
			Route:      route,
			Options: &openapi3filter.Options{
				MultiError: true,
			},
		}

		if err := openapi3filter.ValidateRequest(ctx, requestValidationInput); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Error validating request: %v", err)})
			c.Abort()
			// http.Error(w, fmt.Sprintf("Error validating request: %v", err), http.StatusBadRequest)
			return
		}

		// // Create response recorder
		// rr := httptest.NewRecorder()
		// next.ServeHTTP(rr, r)

		// // Copy response
		// response := rr.Result()

		// Create response recorder to capture the response
		writer := &responseWriter{
			ResponseWriter: c.Writer,
			body:           []byte{},
		}
		c.Writer = writer

		// Process the request
		c.Next()

		// Validate response
		responseValidationInput := &openapi3filter.ResponseValidationInput{
			RequestValidationInput: requestValidationInput,
			Status:                 writer.Status(),
			Header:                 writer.Header(),
			Body:                   io.NopCloser(bytes.NewReader(writer.body)),
			Options: &openapi3filter.Options{
				MultiError: true,
			},
		}

		if route.Operation.OperationID == "LoginPage" {
			responseValidationInput.Options.ExcludeResponseBody = true
		}

		if err := openapi3filter.ValidateResponse(ctx, responseValidationInput); err != nil {
			log.Printf("Error validating response: %v", err)
			// http.Error(w, fmt.Sprintf("Error validating response: %v", err), http.StatusInternalServerError)
			return
		}

		// Copy the validated response to the original writer
		// for k, v := range rr.Header() {
		// 	w.Header()[k] = v
		// }
		// w.WriteHeader(rr.Code)
		// w.Write(rr.Body.Bytes())
		// })
	}
}

func main() {
	ctx := context.Background()

	// Load and parse OpenAPI spec
	loader := openapi3.NewLoader()
	openAPISpec, err := loader.LoadFromFile(OPENAPI_SPEC_FILE_PATH)
	if err != nil {
		log.Fatalf("Error loading swagger spec: %v", err)
	}

	// Validate the OpenAPI spec itself
	err = openAPISpec.Validate(ctx)
	if err != nil {
		log.Fatalf("Error validating swagger spec: %v", err)
	}

	// r := gin.Default()

	// Create router from OpenAPI spec
	router, err := gorillamux.NewRouter(openAPISpec)
	if err != nil {
		log.Fatalf("Error creating router: %v", err)
	}

	// Create Gin router
	gin.SetMode(gin.ReleaseMode)
	ginRouter := gin.New()
	ginRouter.Use(gin.Recovery())

	ginRouter.Use(ValidationMiddleware(router))
	cont := controller.NewOidcController(service.NewOidcService())

	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		log.Fatal("Unable to get the current file path")
	}

	htmlFilePath := filepath.Join(filepath.Dir(filename), filepath.Join("html", "login.html"))

	if _, err := os.Stat(htmlFilePath); os.IsNotExist(err) {
		log.Fatalf("HTML file does not exist at path: %s", htmlFilePath)
	}

	ginRouter.LoadHTMLFiles(htmlFilePath)

	ginRouter.Any("/*path", func(c *gin.Context) {
		c.Header("Access-Control-Allow-Origin", "http://localhost:3000")
		route, _, err := router.FindRoute(c.Request)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Error finding route: %v", err)})
			return
		}

		switch route.Operation.OperationID {
		case "OAuth2Authorize":
			err := cont.OAuth2Authorize(c)
			if err != nil {
				c.AbortWithStatus(http.StatusInternalServerError)
			}
		case "OAuth2TokenOptions":
			c.Header("Access-Control-Allow-Origin", "http://localhost:3000")
			c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
			c.JSON(http.StatusOK, myStruct{})
		case "OAuth2Token":
			c.Header("Access-Control-Allow-Origin", "http://localhost:3000")
			err := cont.OAuth2Token(c)
			if err != nil {
				c.AbortWithStatus(http.StatusInternalServerError)
			}
		case "LoginPage":
			redirectURI := c.Query("redirect_uri")
			parsedURI, err := url.Parse(redirectURI)
			if err != nil || (parsedURI.Scheme == "" && redirectURI != "") {
				log.Printf("Invalid redirect_uri: %s", redirectURI)
				redirectURI = "" // Reset to empty if invalid
			}
			fmt.Println("redirectURI: " + redirectURI)
			hostName := parsedURI.Scheme + "://" + parsedURI.Host
			c.Header("Access-Control-Allow-Origin", hostName)
			c.HTML(http.StatusOK, filepath.Base(htmlFilePath), gin.H{
				"RedirectURI":                 redirectURI,
				"Access-Control-Allow-Origin": redirectURI,
			})
		case "login":
			// r := ctx.Request
			defer c.Request.Body.Close()

			var body api.UserLoginRequest
			if err := c.BindJSON(&body); err != nil {
				c.AbortWithStatus(http.StatusInternalServerError)
			}
			fmt.Println(body)
			url, err := url.Parse(*body.RedirectUri)
			if err != nil {
				c.AbortWithStatus(http.StatusInternalServerError)
			}
			q := url.Query()
			q.Add("code", "abc123")
			url.RawQuery = q.Encode()
			newUrl := url.String()
			// ctx.JSON(http.StatusOK, myStruct{})

			// Add CORS headers explicitly
			// ctx.Header("Access-Control-Allow-Origin", ctx.GetHeader("Origin"))
			// // ctx.Header("Access-Control-Allow-Origin", "https://oauth.pstmn.io/v1/callback")
			// ctx.Header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
			// ctx.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
			// ctx.Header("Access-Control-Expose-Headers", "Location") // Expose Location header for the redirect

			fmt.Println("newUrl: " + newUrl)

			// ctx.JSON(http.StatusBadRequest, myStruct{})
			c.JSON(http.StatusOK, UserLoginResponse{RedirectURL: newUrl})
		default:
			fmt.Println(route.Operation.OperationID)
			c.JSON(http.StatusNoContent, myStruct{})
		}

	})

	// r.POST(OAUTH_TOKEN_ROUTE, func(ctx *gin.Context) {
	// })

	// r.GET(OAUTH_AUTHORIZE_ROUTE, func(ctx *gin.Context) {
	// 	err := cont.OAuth2Authorize(ctx)
	// 	if err != nil {
	// 		ctx.AbortWithStatus(http.StatusInternalServerError)
	// 	}
	// })

	// r.LoadHTMLFiles(htmlFilePath)

	// r.GET("/", func(ctx *gin.Context) {
	// 	ctx.JSON(http.StatusOK, myStruct{})
	// })

	// r.GET("/login", func(ctx *gin.Context) {

	// 	redirectURI := ctx.Query("redirect_uri")
	// 	parsedURI, err := url.Parse(redirectURI)
	// 	if err != nil || (parsedURI.Scheme == "" && redirectURI != "") {
	// 		log.Printf("Invalid redirect_uri: %s", redirectURI)
	// 		redirectURI = "" // Reset to empty if invalid
	// 	}
	// 	fmt.Println("redirectURI: " + redirectURI)
	// 	hostName := parsedURI.Scheme + "://" + parsedURI.Host
	// 	ctx.Header("Access-Control-Allow-Origin", hostName)
	// 	ctx.HTML(http.StatusOK, filepath.Base(htmlFilePath), gin.H{
	// 		"RedirectURI":                 redirectURI,
	// 		"Access-Control-Allow-Origin": redirectURI,
	// 	})
	// 	// ctx.JSON(http.StatusOK, "hello")
	// })

	// origins := []string{
	// 	"http://localhost:3000",          // React development server
	// 	"http://penguin.linux.test:3000", // React development server
	// 	"http://localhost:8080",          // Your current server
	// 	"http://127.0.0.1:3000",
	// 	"http://127.0.0.1:8080",
	// 	"https://oauth.pstmn.io/v1/callback",
	// }
	// r.Use(cors.New(cors.Config{
	// 	AllowOrigins: origins,
	// 	AllowMethods: []string{"GET", "POST", "OPTIONS"},
	// 	AllowHeaders: []string{
	// 		"Origin",
	// 		"Content-Type",
	// 		"Accept",
	// 		"Authorization",
	// 	},
	// 	ExposeHeaders: []string{
	// 		"Content-Length",
	// 		"Location", // Important for redirect headers
	// 	},
	// 	AllowCredentials: true,
	// }))

	// r.POST(USERS_LOGIN, func(ctx *gin.Context) {

	// 	r := ctx.Request
	// 	defer r.Body.Close()

	// 	var body api.LoginDto
	// 	if err := ctx.BindJSON(&body); err != nil {
	// 		ctx.AbortWithStatus(http.StatusInternalServerError)
	// 	}
	// 	fmt.Println(body)
	// 	url, err := url.Parse(*body.RedirectUri)
	// 	if err != nil {
	// 		ctx.AbortWithStatus(http.StatusInternalServerError)
	// 	}
	// 	q := url.Query()
	// 	q.Add("code", "abc123")
	// 	url.RawQuery = q.Encode()
	// 	newUrl := url.String()
	// 	// ctx.JSON(http.StatusOK, myStruct{})

	// 	// Add CORS headers explicitly
	// 	// ctx.Header("Access-Control-Allow-Origin", ctx.GetHeader("Origin"))
	// 	// // ctx.Header("Access-Control-Allow-Origin", "https://oauth.pstmn.io/v1/callback")
	// 	// ctx.Header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
	// 	// ctx.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
	// 	// ctx.Header("Access-Control-Expose-Headers", "Location") // Expose Location header for the redirect

	// 	fmt.Println("newUrl: " + newUrl)

	// 	// ctx.JSON(http.StatusBadRequest, myStruct{})
	// 	ctx.JSON(http.StatusOK, UserLoginResponse{RedirectURL: newUrl})
	// })

	port := env.GetPort()
	log.Printf("Server starting on :%s", port)
	ginRouter.Run(fmt.Sprintf(":%s", port))
}

type UserLoginResponse struct {
	RedirectURL string `json:"redirectUrl"`
}

type myStruct struct{}
